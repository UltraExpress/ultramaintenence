<!DOCTYPE html>
<html>
<head>
    <title>Upload Test</title>
    <style>
        body { font-family: Arial; padding: 20px; }
        .status { margin: 10px 0; padding: 10px; background: #f0f0f0; }
        img.preview { max-width: 300px; display: none; margin: 10px 0; }
        .loading { display: none; color: #666; }
    </style>
</head>
<body>
    <h2>Upload Test</h2>
    <div id="status" class="status">Ready</div>
    <div id="loading" class="loading">Processing...</div>
    <button onclick="document.getElementById('photoInput').click()">Take Photo</button>
    <input type="file" id="photoInput" accept="image/*" capture="environment" style="display: none">
    <img id="photoPreview" class="preview">

    <script>
        const API_URL = 'https://script.google.com/macros/s/AKfycbzL9ffrICvYzdGEnDoj_DV2zoJZQC2wPigydwaG4MZLwAboOwPGBC3BJFsVFn8qt8x0Ww/exec';
        let photoData = null;

        // Compression function - exact same as maintenance app
        async function compressImage(base64String) {
            return new Promise((resolve) => {
                const img = new Image();
                img.src = base64String;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    let width = img.width;
                    let height = img.height;
                    const maxSize = 800;
                    
                    if (width > height && width > maxSize) {
                        height = (height * maxSize) / width;
                        width = maxSize;
                    } else if (height > maxSize) {
                        width = (width * maxSize) / height;
                        height = maxSize;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg', 0.7));
                };
            });
        }

        // Handle photo input - exact same as maintenance app
        document.getElementById('photoInput').addEventListener('change', function(e) {
            if (e.target.files && e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    photoData = e.target.result;
                    document.getElementById('photoPreview').src = photoData;
                    document.getElementById('photoPreview').style.display = 'block';
                    uploadPhoto();
                };
                reader.readAsDataURL(e.target.files[0]);
            }
        });

        // Upload function - exact same chunking as maintenance app
        async function uploadPhoto() {
            if (!photoData) return;
            
            const loading = document.getElementById('loading');
            const status = document.getElementById('status');
            loading.style.display = 'block';
            
            try {
                // Compress image
                const compressedPhoto = await compressImage(photoData);
                
                // Prepare the data exactly like maintenance app
                const formData = {
                    location: "TEST",
                    name: "TEST",
                    partId: "TEST_" + Date.now(),
                    partName: "TEST PART",
                    photo: compressedPhoto.split(',')[1]
                };

                // Split into chunks - exact same as maintenance app
                const serializedData = JSON.stringify(formData);
                const chunkSize = 30000;
                const chunks = [];

                for (let i = 0; i < serializedData.length; i += chunkSize) {
                    chunks.push(serializedData.slice(i, i + chunkSize));
                }

                // Send chunks
                for (let i = 0; i < chunks.length; i++) {
                    const chunkData = {
                        chunk: chunks[i],
                        index: i,
                        total: chunks.length,
                        isLast: i === chunks.length - 1
                    };

                    loading.textContent = `Uploading chunk ${i + 1}/${chunks.length}`;

                    await fetch(API_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: {
                            'Content-Type': 'text/plain',
                        },
                        body: JSON.stringify(chunkData)
                    });
                }

                status.textContent = 'Upload complete!';
            } catch (error) {
                status.textContent = 'Error: ' + error.message;
                console.error('Upload error:', error);
            } finally {
                loading.style.display = 'none';
            }
        }
    </script>
</body>
</html>
